import Foundation

struct LinkedListValue<T> {
    var key: T
    var value: Int
}

class LinkedListNode<T> {
    var value: T
    var next: LinkedListNode?
    weak var previous: LinkedListNode?

    public init(value: T) {
        self.value = value
    }
}

class LinkedList<T> {
    private var head: LinkedListNode<T>?
    private var tail: LinkedListNode<T>?

    var isEmpty: Bool {
        return head == nil
    }

    var first: LinkedListNode<T>? {
        return head
    }
    
    var last: LinkedListNode<T>? {
        guard var node = head else { return nil }
  
        while let next = node.next {
            node = next
        }
        return node
    }
    
    func add(value: T) {
      let newNode = LinkedListNode<T>(value: value)
      if let tailNode = tail {
        newNode.previous = tailNode
        tailNode.next = newNode
      } else {
        head = newNode
      }
      tail = newNode
    }
}

class HashTableNode<T> {
    var value: T
    var key: Int
    var nextNode: HashTableNode?
    init(value: T, key: Int) {
        self.value = value
        self.key = key
    }
}

class SymbolTable<T> {
    private var bucket: [HashTableNode<T>?]
    
    init(bucketSize: Int) {
        bucket = Array(repeating: nil, count: bucketSize)
    }
    
    func addElement(_ element: T) {
        let hashKey = bucket.compactMap { $0 }.count
        let node = HashTableNode(value: element, key: hashKey)
        let index = findIndex(forKey: hashKey)
        var auxNode = bucket[index]
        if auxNode == nil {
           bucket[index] = node
            return
        }
        while auxNode?.nextNode != nil {
            if auxNode?.key == hashKey || auxNode?.nextNode?.key == hashKey {
                auxNode = [auxNode, auxNode?.nextNode].first(where: {$0?.key == hashKey})!
                auxNode?.value = element
            }
            auxNode = auxNode?.nextNode
        }
        auxNode?.nextNode = node
    }
    
    func getElement(forKey hashKey: Int) -> T? {
        let index = findIndex(forKey: hashKey)
        var node = bucket[index]
        while node != nil {
            if node?.key == hashKey { return node?.value } else {
                node = node?.nextNode
            }
        }
        return nil
    }
    
    private func findIndex(forKey hashKey: Int) -> Int {
        return (hashKey >= 0 ? hashKey % bucket.capacity : -1)
    }
}

class Scanner {
    private let ReservedWords = ["if", "elif", "else", "class", "struct", "nil", "let", "var", "int", "init", "deinit", "char", "string", "array", "for", "forEach", "do", "try", "catch", "readLine", "print", "while"]
    private let Separators = ["[", "]", "{", "}", "(", ")", ":", "->", "."]
    private let Operators = ["+", "-", "*", "/", "=", "==", "<", ">", "<", "=", ">", "=", "|", "|", "&", "&", "%", "!", "!=", "++"]
    
    private var programTokens: [String] {
        ReservedWords + Separators + Operators
    }
    
    private let symbolTable = SymbolTable<String>(bucketSize: 131)
    private let programInternalForm = LinkedList<LinkedListValue<Int>>()
    
    private func completeTokenization(components: [String]) -> [LinkedListValue<String>] {
        var completeTokens = [LinkedListValue<String>]()
        var currentString = ""
        var inString = false
        var lineNumber = 1
        components.forEach { component in
            if component == "\"" {
                if inString {
                    completeTokens.append(LinkedListValue(key: component, value: lineNumber))
                    currentString = ""
                }
                inString.toggle()
            } else if component == "\n" {
                lineNumber += 1
            } else {
                if inString {
                    currentString += component
                } else if component == " " {
                    completeTokens.append(LinkedListValue(key: component, value: lineNumber))
                }
            }
        }
        return completeTokens
    }
    
    private func tokenize(content: String) -> [LinkedListValue<String>] {
        let separators = Separators.reduce("") { $0 + $1 }
        let components = content.components(separatedBy: separators)
        return completeTokenization(components: components)
    }
    
    private func scan() {
        let tokens = tokenize(content: "Example")
        var foundLexicalError = false
        if tokens.isEmpty { return }
        tokens.forEach { token in
            let key = token.key
            if ReservedWords.contains(key) {
                programInternalForm.add(value: LinkedListValue<Int>(key: -1, value: 2))
            } else if Separators.contains(key) {
                programInternalForm.add(value: LinkedListValue<Int>(key: -1, value: 3))
            } else if Operators.contains(key) {
                programInternalForm.add(value: LinkedListValue<Int>(key: -1, value: 4))
            } else if key.range(of: "[a-zA-Z][a-zA-Z0-9]*", options: .regularExpression) != nil {
                // Identifier
                symbolTable.addElement(key)
                programInternalForm.add(value: LinkedListValue<Int>(key: programTokens.firstIndex(of: key)!, value: 0))
            } else if key.range(of: "[a-zA-Z0-9 \\-.,!@#$%^&*()]*", options: .regularExpression) != nil {
                // Constant
                symbolTable.addElement(key)
                programInternalForm.add(value: LinkedListValue<Int>(key: programTokens.firstIndex(of: key)!, value: 1))
            } else {
                print("Lexical error found on line \(token.value)")
                foundLexicalError = true
            }
        }
        if !foundLexicalError {
            print("Program is lexically correct")
        }
    }
}
